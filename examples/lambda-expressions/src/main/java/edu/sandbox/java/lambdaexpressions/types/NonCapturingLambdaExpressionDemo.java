package edu.sandbox.java.lambdaexpressions.types;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.function.Consumer;
import java.util.function.IntBinaryOperator;

public class NonCapturingLambdaExpressionDemo {

    private static final Logger log = LoggerFactory.getLogger(NonCapturingLambdaExpressionDemo.class);

    private static final int AMOUNT_OF_EXECUTIONS = 5;

    public static void main(String[] args) {
        for (int i = 0; i < AMOUNT_OF_EXECUTIONS; i++) {
            new NonCapturingLambdaExpressionDemo().startExample();
        }
    }

    // Non-Capturing Lambda Expressions don't use external variables or instance methods, except static fields or methods
    // You can check what will be generated by LambdaMetafactory using flag: -Djdk.internal.lambda.dumpProxyClasses=./examples/lambda-expressions/src/main/generated
    // or check already generated file within 'generated' directory
    private void startExample() {
        // Lambda Expression with link to static field
        Runnable runnable = () -> log.info("Non-capturing lambda without parameters");
        runnable.run();

        // LambdaExpression with link to static field and parameter
        Consumer<String> consumer = message -> log.info("Non-capturing lambda with parameter: {}", message);
        consumer.accept("Some argument");

        // LambdaExpression with multiple parameters
        IntBinaryOperator biFunction = (a, b) -> a + b;
        log.info("Non-capturing lambda with multiple parameters: {}", biFunction.applyAsInt(2, 3));

        // each call we will see the same hash code, because LambdaMetafactory doesn't create a new lambda each time for non-capturing lambdas
        log.info(">>>> runnable.hashCode = {}", runnable.hashCode());
        log.info(">>>> consumer.hashCode = {}", consumer.hashCode());
        log.info(">>>> biFunction.hashCode = {}", biFunction.hashCode());
    }
}
