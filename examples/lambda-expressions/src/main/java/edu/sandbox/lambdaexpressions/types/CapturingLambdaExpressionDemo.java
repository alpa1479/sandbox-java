package edu.sandbox.lambdaexpressions.types;

import lombok.extern.slf4j.Slf4j;

import java.util.function.Consumer;
import java.util.function.IntUnaryOperator;

@Slf4j
public class CapturingLambdaExpressionDemo {

    private static final int AMOUNT_OF_EXECUTIONS = 5;

    private String instanceVariable = "Prefix";

    public static void main(String[] args) {
        for (int i = 0; i < AMOUNT_OF_EXECUTIONS; i++) {
            new CapturingLambdaExpressionDemo().startExample();
        }
    }

    // Capturing Lambda Expressions use non-static variables or instance methods
    // You can check what will be generated by LambdaMetafactory by using flag: -Djdk.internal.lambda.dumpProxyClasses=./examples/lambda-expressions/src/main/generated
    // or check already generated file within 'generated' directory
    private void startExample() {
        // Lambda Expression with link to local variable
        var factor = 2;
        IntUnaryOperator multiplier = number -> number * factor;
        log.info("multiplier = {}", multiplier.applyAsInt(5));

        // Lambda Expression with link to instance variable
        Consumer<String> consumer = message -> log.info("{} {}", instanceVariable, message);
        consumer.accept("Some argument");

        // Lambda Expression with link to instance method
        Runnable runnable = () -> instanceMethod();
        runnable.run();

        // each call we will see different hash code, because LambdaMetafactory creates a new lambda each time for capturing lambdas
        // class e.g. CapturingLambdaExpressionDemo$$Lambda$27 will be generated only once, but each time it will create new object of this class
        log.info(">>>> multiplier.hashCode = {}", multiplier.hashCode());
        log.info(">>>> consumer.hashCode = {}", consumer.hashCode());
        log.info(">>>> runnable.hashCode = {}", runnable.hashCode());
    }

    private void instanceMethod() {
        log.info("CapturingLambdaExpressionDemo.instanceMethod");
    }
}
